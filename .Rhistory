library(tidyverse)
library(dplyr)
library(zoo)
library(snow)
library(devtools)
#install_github('desmarais-lab/NetworkInference')
library(NetworkInference)
library(ergm)
library(btergm)
library(statnet)
library(speedglm)
library(kableExtra)
library(data.table)
#library(networkDynamic)
# --- Parallel execution over draws ----
library(future)
library(future.apply)
library(parallelly)
availableCores()
set.seed(54789)
# Set window for number of years of treaty signing to include in dynamic network inference
WINDOW = 20
# Set p-value for identifying ties
PVALUE = 0.05
dyad_ivs <-fread("../ddyad_ivs.csv")
# Load the data on treaty signing years
UNtreaty_sign <- fread("../../data/UNtreaty_data_sign.csv")
UNtreaty_sign <- UNtreaty_sign |>
filter(!grepl("succession", Action, ignore.case = TRUE)) |>               ## get rid of signature by state succession
mutate(cname=replace(cname, cname=="GFR", "GMY"),                          ## West Germany -> Germany
ccode=replace(ccode, ccode==260, 255)) |>
group_by(reg_num_id, ccode) |>
filter(sign_year==min(sign_year))|>
distinct(reg_num_id, ccode, .keep_all=TRUE) |>
filter(environ == 1)                                                  		## Just environmental treaties
##########################################
###############Parallel Code##############
##########################################
# --- One-draw worker function ----
one_draw <- function(draw,
UNtreaty_sign_unique,
UNtreaty_sign,
dyad_ivs,
country_ivs_path = "../country_ivs.csv",
write_intermediate = FALSE) {
# Load packages in worker
suppressPackageStartupMessages({
library(dplyr); library(tidyr); library(network); library(btergm); library(data.table); library(netdiffuseR); library(NetworkInference)     # if needed
})
# 1) Sample treaties (w/ replacement)
UNtreaty_sign_sample_treaties <- data.frame(
reg_num_id = sample(UNtreaty_sign_unique,
size = length(UNtreaty_sign_unique),
replace = TRUE)
)
# 2) Merge signatures (many-to-many)
UNtreaty_sign_sample <- UNtreaty_sign_sample_treaties |>
left_join(UNtreaty_sign, by = "reg_num_id", relationship = "many-to-many") |>
arrange(reg_num_id, ccode) |>
group_by(reg_num_id, ccode) |>
mutate(seq_num = sequence(n())) |>
group_by(reg_num_id, seq_num) |>
mutate(reg_num_id_bs = cur_group_id()) |>
ungroup()
#Clean up:
rm(UNtreaty_sign_sample_treaties)
gc()
# 3) Build dynamic diffusion network over time
length_years<-length(1945:2018)
edges_list <- vector("list", length_years)
Year <- 1945
while (Year <= 2018) {
t_cascades_env <- UNtreaty_sign_sample |>
filter(sign_year >  Year - WINDOW,
sign_year <= Year) |>
as_cascade_long(cascade_node_name = "cname",
event_time       = "sign_year",
cascade_id       = "reg_num_id_bs")
treatyDataSubsetNetworkAll_env <- netinf(
t_cascades_env,
p_value_cutoff = PVALUE,
quiet = TRUE
)
edges_df <- cbind.data.frame(origin_node=treatyDataSubsetNetworkAll_env$origin_node,
destination_node = treatyDataSubsetNetworkAll_env$destination_node,
p_value=treatyDataSubsetNetworkAll_env$p_value,
year = Year)
edges_list[[i]] <- edges_df
i<-i+1
Year <- Year + 1
rm(t_cascades_env, treatyDataSubsetNetworkAll_env, edges_df)
gc()
}
estNetDynamicAll_env <- dplyr::bind_rows(edges_list)
#Clean up to save memory:
rm(UNtreaty_sign_sample, UNtreaty_sign, edges_list)
gc()
# Optionally write per-draw CSV
if (isTRUE(write_intermediate)) {
out_csv <- sprintf("window20_p05/networks/UNtreaty_bootstrap_netinf_dynamic_allpast_env_%03d.csv", draw)
write.csv(estNetDynamicAll_env, file = out_csv, row.names = FALSE)
}
# 4) Build DV & attributes (use in-memory object, no read.csv)
edgelist_env <- estNetDynamicAll_env |>
filter(year >= 1960, year <= 2017) |>
mutate(
origin_node      = ifelse(origin_node == "GMY" & year < 1990, "GFR", origin_node),
destination_node = ifelse(destination_node == "GMY" & year < 1990, "GFR", destination_node),
tie = 1
) |>
right_join(dyad_ivs, by = c("origin_node" = "cname1",
"destination_node" = "cname2",
"year")) |>
mutate(tie = ifelse(is.na(tie), 0, tie)) |>
distinct() |>
mutate(outdegree = sum(tie), .by = c(origin_node, year)) |>
arrange(origin_node, destination_node, year) |>
group_by(origin_node, destination_node) |>
mutate(l_outdegree = dplyr::lag(outdegree)) |>
arrange(origin_node, year) |>
ungroup()
rm(estNetDynamicAll_env, dyad_ivs)
gc()
# Country-level IVs
country_ivs <- fread(country_ivs_path) |>
dplyr::select(ccode, cname, year, ln_pec, ln_pec_percap, tpop, cinc,
log_gdp, log_gdppc, n_IGO, n_ingo_hq, pec_change, major, vdem_bin) |>
group_by(ccode) |> arrange(year) |>
mutate(n_IGO = ifelse(is.na(n_IGO), 0, n_IGO)) |>
filter(year >= 1945) |> ungroup()
country_ivs <- edgelist_env |>
group_by(origin_node, year) |>
summarise(l_outdegree = if (all(is.na(l_outdegree))) 0 else max(l_outdegree, na.rm = TRUE),
.groups = "keep") |>
mutate(l_outdegree = ifelse(is.infinite(l_outdegree) | is.na(l_outdegree), 0, l_outdegree)) |>
right_join(country_ivs, by = c("origin_node" = "cname", "year")) |>
dplyr::select(cname = origin_node, dplyr::everything()) |>
ungroup()
# 5) Build dyad arrays & network list
dyadVars <- c("lang", "legacy", "sec_lang", "defense", "conttype", "ln_dyad_trade_GDP")
yrs <- seq(min(edgelist_env$year), max(edgelist_env$year))
# Dyad arrays
dyadArrays <- vector("list", length(yrs))
for (i in seq_along(yrs)) {
yr <- yrs[i]
d <- dplyr::filter(edgelist_env, year == yr)
actors <- sort(unique(c(d$origin_node, d$destination_node)))
n <- length(actors); p <- length(dyadVars)
dyadArray <- array(0, dim = c(n, n, p),
dimnames = list(actors, actors, dyadVars))
for (param in dyadVars) {
for (r in seq_len(nrow(d))) {
a1 <- d$origin_node[r]; a2 <- d$destination_node[r]
dyadArray[a1, a2, param] <- as.numeric(d[r, param])
}
}
dyadArrays[[i]] <- dyadArray
}
# Networks
netlist <- vector("list", length(yrs))
for (i in seq_along(yrs)) {
yr <- yrs[i]
d <- dplyr::filter(edgelist_env, year == yr) |>
dplyr::select(origin_node, destination_node, tie) |>
arrange(origin_node, destination_node) |>
mutate(tie = ifelse(is.na(tie), 0, tie)) |>
tidyr::pivot_wider(id_cols = origin_node,
names_from = destination_node,
values_from = tie) |>
as.data.frame()
# ensure a consistent column order starting with AFG if present
if ("AFG" %in% names(d)) d <- d |> dplyr::select(origin_node, AFG, dplyr::everything())
rownames(d) <- d$origin_node
d[, 1] <- NULL
m <- as.matrix(d)
net <- network(m, matrix.type = "adjacency", directed = TRUE, loops = FALSE)
set.network.attribute(net, "year", yr)
netlist[[i]] <- net
}
#Clean up:
rm(edgelist_env, net, d)
gc()
# Attach dyad covariates
for (param in dyadVars) {
for (i in seq_along(yrs)) {
set.network.attribute(netlist[[i]], param, dyadArrays[[i]][,,param])
}
}
#Clean up:
rm(dyadArrays)
gc()
# Vertex attributes
attrs<- c("ln_pec", "ln_pec_percap", "tpop", "cinc", "n_IGO", "n_ingo_hq", "pec_change", "major", "vdem_bin","l_outdegree")
for (attr in attrs) {
for (i in 1:length(yrs)){
yr=yrs[1]+i-1
set.network.attribute(netlist[[i]],'vertex.pid','vertex.names')
pids<-get.vertex.pid(netlist[[i]])
d<- dplyr::filter(country_ivs, year==yr)
vals<-NULL
for (j in pids){
val<- d[d$cname==j,attr]
vals<-c(vals,val)
}
set.vertex.attribute(netlist[[i]],attrname=attr,value=vals, vertex.pid=pids)
}
}
#Clean up:
rm(country_ivs)
gc()
for (i in seq_along(netlist)) {
for (attr in attrs) {
if (!(attr %in% list.vertex.attributes(netlist[[i]]))) {
set.vertex.attribute(netlist[[i]], attr, rep(0, network.size(netlist[[i]])))
}
}
}
netlist_out <- netlist[2:length(netlist)]
#Clean up:
rm(netlist,  d,  m)
gc()
#Subset to 1960 and later:
#  network_yrs <- lapply(netlist_out, function(net) get.network.attribute(net, "year"))
#  netlist_sub <- netlist_out[network_yrs<=2017 & network_yrs>=1960]
# 6) Fit model (can still use internal snow parallelism per draw if you want)
suppressWarnings(est2_env <- btergm(
netlist_out ~ edges + mutual + dgwesp(decay = .5, fixed = TRUE) +
nodeocov("l_outdegree") +
nodeocov("ln_pec") + nodeicov("ln_pec") +
nodeocov("ln_pec_percap") + nodeicov("ln_pec_percap") +
nodeocov("vdem_bin") + nodeicov("vdem_bin") +
nodeocov("major")   + nodeicov("major") +
nodeocov("n_IGO")   + nodeicov("n_IGO") +
nodeocov("n_ingo_hq") + nodeicov("n_ingo_hq") +
nodematch("vdem_bin") +
edgecov("conttype") + edgecov("defense") +
edgecov("lang") + edgecov("legacy") +
timecov(),
R = 10, parallel = "no", ncpus = 1
))
#  est_sum <- summary(est2_env)
# Access the time-bootstrapped coefficient vectors from a single run of btergm
est_sum_boot <- attributes(est2_env)$boot$t
rm(est2_env, netlist_out)
gc()
return(est_sum_boot)
}
# Reproducible RNG across workers
RNGkind("L'Ecuyer-CMRG")
closeAllConnections()
plan(multisession, workers = max(1, availableCores() - 4))
num_sim <- 100
UNtreaty_sign_unique <- unique(UNtreaty_sign$reg_num_id)
system.time({
result_list <- future_lapply(
X = seq_len(num_sim),
FUN = one_draw,
UNtreaty_sign_unique = UNtreaty_sign_unique,
UNtreaty_sign        = UNtreaty_sign,
dyad_ivs             = dyad_ivs,
country_ivs_path     = "../country_ivs.csv",
write_intermediate   = TRUE,
future.seed = TRUE   # reproducible per-draw seeds
)
})
set.seed(54789)
# Set window for number of years of treaty signing to include in dynamic network inference
WINDOW = 20
# Set p-value for identifying ties
PVALUE = 0.05
dyad_ivs <-fread("../ddyad_ivs.csv")
# Load the data on treaty signing years
UNtreaty_sign <- fread("../../data/UNtreaty_data_sign.csv")
UNtreaty_sign <- UNtreaty_sign |>
filter(!grepl("succession", Action, ignore.case = TRUE)) |>               ## get rid of signature by state succession
mutate(cname=replace(cname, cname=="GFR", "GMY"),                          ## West Germany -> Germany
ccode=replace(ccode, ccode==260, 255)) |>
group_by(reg_num_id, ccode) |>
filter(sign_year==min(sign_year))|>
distinct(reg_num_id, ccode, .keep_all=TRUE) |>
filter(environ == 1)                                                  		## Just environmental treaties
##########################################
###############Parallel Code##############
##########################################
# --- One-draw worker function ----
one_draw <- function(draw,
UNtreaty_sign_unique,
UNtreaty_sign,
dyad_ivs,
country_ivs_path = "../country_ivs.csv",
write_intermediate = FALSE) {
# Load packages in worker
suppressPackageStartupMessages({
library(dplyr); library(tidyr); library(network); library(btergm); library(data.table); library(netdiffuseR); library(NetworkInference)     # if needed
})
# 1) Sample treaties (w/ replacement)
UNtreaty_sign_sample_treaties <- data.frame(
reg_num_id = sample(UNtreaty_sign_unique,
size = length(UNtreaty_sign_unique),
replace = TRUE)
)
# 2) Merge signatures (many-to-many)
UNtreaty_sign_sample <- UNtreaty_sign_sample_treaties |>
left_join(UNtreaty_sign, by = "reg_num_id", relationship = "many-to-many") |>
arrange(reg_num_id, ccode) |>
group_by(reg_num_id, ccode) |>
mutate(seq_num = sequence(n())) |>
group_by(reg_num_id, seq_num) |>
mutate(reg_num_id_bs = cur_group_id()) |>
ungroup()
#Clean up:
rm(UNtreaty_sign_sample_treaties)
gc()
# 3) Build dynamic diffusion network over time
length_years<-length(1945:2018)
edges_list <- vector("list", length_years)
i=1
Year <- 1945
while (Year <= 2018) {
t_cascades_env <- UNtreaty_sign_sample |>
filter(sign_year >  Year - WINDOW,
sign_year <= Year) |>
as_cascade_long(cascade_node_name = "cname",
event_time       = "sign_year",
cascade_id       = "reg_num_id_bs")
treatyDataSubsetNetworkAll_env <- netinf(
t_cascades_env,
p_value_cutoff = PVALUE,
quiet = TRUE
)
edges_df <- cbind.data.frame(origin_node=treatyDataSubsetNetworkAll_env$origin_node,
destination_node = treatyDataSubsetNetworkAll_env$destination_node,
p_value=treatyDataSubsetNetworkAll_env$p_value,
year = Year)
edges_list[[i]] <- edges_df
i<-i+1
Year <- Year + 1
rm(t_cascades_env, treatyDataSubsetNetworkAll_env, edges_df)
gc()
}
estNetDynamicAll_env <- dplyr::bind_rows(edges_list)
#Clean up to save memory:
rm(UNtreaty_sign_sample, UNtreaty_sign, edges_list)
gc()
# Optionally write per-draw CSV
if (isTRUE(write_intermediate)) {
out_csv <- sprintf("window20_p05/networks/UNtreaty_bootstrap_netinf_dynamic_allpast_env_%03d.csv", draw)
write.csv(estNetDynamicAll_env, file = out_csv, row.names = FALSE)
}
# 4) Build DV & attributes (use in-memory object, no read.csv)
edgelist_env <- estNetDynamicAll_env |>
filter(year >= 1960, year <= 2017) |>
mutate(
origin_node      = ifelse(origin_node == "GMY" & year < 1990, "GFR", origin_node),
destination_node = ifelse(destination_node == "GMY" & year < 1990, "GFR", destination_node),
tie = 1
) |>
right_join(dyad_ivs, by = c("origin_node" = "cname1",
"destination_node" = "cname2",
"year")) |>
mutate(tie = ifelse(is.na(tie), 0, tie)) |>
distinct() |>
mutate(outdegree = sum(tie), .by = c(origin_node, year)) |>
arrange(origin_node, destination_node, year) |>
group_by(origin_node, destination_node) |>
mutate(l_outdegree = dplyr::lag(outdegree)) |>
arrange(origin_node, year) |>
ungroup()
rm(estNetDynamicAll_env, dyad_ivs)
gc()
# Country-level IVs
country_ivs <- fread(country_ivs_path) |>
dplyr::select(ccode, cname, year, ln_pec, ln_pec_percap, tpop, cinc,
log_gdp, log_gdppc, n_IGO, n_ingo_hq, pec_change, major, vdem_bin) |>
group_by(ccode) |> arrange(year) |>
mutate(n_IGO = ifelse(is.na(n_IGO), 0, n_IGO)) |>
filter(year >= 1945) |> ungroup()
country_ivs <- edgelist_env |>
group_by(origin_node, year) |>
summarise(l_outdegree = if (all(is.na(l_outdegree))) 0 else max(l_outdegree, na.rm = TRUE),
.groups = "keep") |>
mutate(l_outdegree = ifelse(is.infinite(l_outdegree) | is.na(l_outdegree), 0, l_outdegree)) |>
right_join(country_ivs, by = c("origin_node" = "cname", "year")) |>
dplyr::select(cname = origin_node, dplyr::everything()) |>
ungroup()
# 5) Build dyad arrays & network list
dyadVars <- c("lang", "legacy", "sec_lang", "defense", "conttype", "ln_dyad_trade_GDP")
yrs <- seq(min(edgelist_env$year), max(edgelist_env$year))
# Dyad arrays
dyadArrays <- vector("list", length(yrs))
for (i in seq_along(yrs)) {
yr <- yrs[i]
d <- dplyr::filter(edgelist_env, year == yr)
actors <- sort(unique(c(d$origin_node, d$destination_node)))
n <- length(actors); p <- length(dyadVars)
dyadArray <- array(0, dim = c(n, n, p),
dimnames = list(actors, actors, dyadVars))
for (param in dyadVars) {
for (r in seq_len(nrow(d))) {
a1 <- d$origin_node[r]; a2 <- d$destination_node[r]
dyadArray[a1, a2, param] <- as.numeric(d[r, param])
}
}
dyadArrays[[i]] <- dyadArray
}
# Networks
netlist <- vector("list", length(yrs))
for (i in seq_along(yrs)) {
yr <- yrs[i]
d <- dplyr::filter(edgelist_env, year == yr) |>
dplyr::select(origin_node, destination_node, tie) |>
arrange(origin_node, destination_node) |>
mutate(tie = ifelse(is.na(tie), 0, tie)) |>
tidyr::pivot_wider(id_cols = origin_node,
names_from = destination_node,
values_from = tie) |>
as.data.frame()
# ensure a consistent column order starting with AFG if present
if ("AFG" %in% names(d)) d <- d |> dplyr::select(origin_node, AFG, dplyr::everything())
rownames(d) <- d$origin_node
d[, 1] <- NULL
m <- as.matrix(d)
net <- network(m, matrix.type = "adjacency", directed = TRUE, loops = FALSE)
set.network.attribute(net, "year", yr)
netlist[[i]] <- net
}
#Clean up:
rm(edgelist_env, net, d)
gc()
# Attach dyad covariates
for (param in dyadVars) {
for (i in seq_along(yrs)) {
set.network.attribute(netlist[[i]], param, dyadArrays[[i]][,,param])
}
}
#Clean up:
rm(dyadArrays)
gc()
# Vertex attributes
attrs<- c("ln_pec", "ln_pec_percap", "tpop", "cinc", "n_IGO", "n_ingo_hq", "pec_change", "major", "vdem_bin","l_outdegree")
for (attr in attrs) {
for (i in 1:length(yrs)){
yr=yrs[1]+i-1
set.network.attribute(netlist[[i]],'vertex.pid','vertex.names')
pids<-get.vertex.pid(netlist[[i]])
d<- dplyr::filter(country_ivs, year==yr)
vals<-NULL
for (j in pids){
val<- d[d$cname==j,attr]
vals<-c(vals,val)
}
set.vertex.attribute(netlist[[i]],attrname=attr,value=vals, vertex.pid=pids)
}
}
#Clean up:
rm(country_ivs)
gc()
for (i in seq_along(netlist)) {
for (attr in attrs) {
if (!(attr %in% list.vertex.attributes(netlist[[i]]))) {
set.vertex.attribute(netlist[[i]], attr, rep(0, network.size(netlist[[i]])))
}
}
}
netlist_out <- netlist[2:length(netlist)]
#Clean up:
rm(netlist,  d,  m)
gc()
#Subset to 1960 and later:
#  network_yrs <- lapply(netlist_out, function(net) get.network.attribute(net, "year"))
#  netlist_sub <- netlist_out[network_yrs<=2017 & network_yrs>=1960]
# 6) Fit model (can still use internal snow parallelism per draw if you want)
suppressWarnings(est2_env <- btergm(
netlist_out ~ edges + mutual + dgwesp(decay = .5, fixed = TRUE) +
nodeocov("l_outdegree") +
nodeocov("ln_pec") + nodeicov("ln_pec") +
nodeocov("ln_pec_percap") + nodeicov("ln_pec_percap") +
nodeocov("vdem_bin") + nodeicov("vdem_bin") +
nodeocov("major")   + nodeicov("major") +
nodeocov("n_IGO")   + nodeicov("n_IGO") +
nodeocov("n_ingo_hq") + nodeicov("n_ingo_hq") +
nodematch("vdem_bin") +
edgecov("conttype") + edgecov("defense") +
edgecov("lang") + edgecov("legacy") +
timecov(),
R = 10, parallel = "no", ncpus = 1
))
#  est_sum <- summary(est2_env)
# Access the time-bootstrapped coefficient vectors from a single run of btergm
est_sum_boot <- attributes(est2_env)$boot$t
rm(est2_env, netlist_out)
gc()
return(est_sum_boot)
}
# Reproducible RNG across workers
RNGkind("L'Ecuyer-CMRG")
closeAllConnections()
plan(multisession, workers = max(1, availableCores() - 4))
num_sim <- 100
UNtreaty_sign_unique <- unique(UNtreaty_sign$reg_num_id)
system.time({
result_list <- future_lapply(
X = seq_len(num_sim),
FUN = one_draw,
UNtreaty_sign_unique = UNtreaty_sign_unique,
UNtreaty_sign        = UNtreaty_sign,
dyad_ivs             = dyad_ivs,
country_ivs_path     = "../country_ivs.csv",
write_intermediate   = TRUE,
future.seed = TRUE   # reproducible per-draw seeds
)
})
